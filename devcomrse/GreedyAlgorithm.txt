완주하지 못한 선수

해시(hash)

python 사전(dictionary)
d = {"leo": 30 , "kiki": 62, "eden": 5}
x = d["leo"]
d["leo"] = 58

사전의 원소들을 해시를 이용해 O(1) 시간에 접근가능 

def solution(participant, completion):
	d = {}
	for x in participant:
		d[x] = d.get(x,0) +1
	for x in completion:
		d[x] -= 1
	dnf = [k for k , v in d.items() if v > 0]
	answer = dnf[0]
	return answer


탐욕법(Greedy Algorithm)
	알고리즘의 각 단계에서 그 순간에 최적이라고 생각되는 것을 선택

탐욕법 : 체육복
1 < n <= 30
def solution(n, lost, reserve):
	u = [1] * (n + 2)
	for i in reserve:
		u[i] += 1
	for i in lost:
		u[i] -= 1
	for i in range(1, n + 1):
		if u[i - 1] == 0 and u[i] == 2:
			u[i - 1:i+1] = [1, 1]
		elif u[i] == and u[i + 1] ==0:
			u[i:i +2] = [1, 1]
	return len([x for x in u[1: -1] if x > 0])


만약 n이 큰 경우
def solution(n, lost, reserve):
	s = set(lost) & set(reserve)
	l = set(lost) - s
	r = set(reserve) - s

	for x in sorted(r):
		if x - 1 in l:
			l.remove(x -1)
		elif x +1 in l:
			l.remove(x + 1)
	return n - len(l)


sort : 가장 큰수
def solution(numbers):
	numbers = [str(x) for x in numbers]
	numbers.sort(key=lambda x : (x * 4)[:4], reverse=True)
	if numbers[0] =='0':
		answer='0'
	else:
		answer = ''.join(numbers)

탐욕법 : 큰수 만들기
def solution(number, k):
	collected = []
	for i, num in enumerate(number):
		while len(collected) > and collected[-1] < num and k>0:
			collected.pop()
			k-=1
		if k ==0:
			collected += list(number[i:])
			break

		collected.append(num)
	
	collected = collected[:-k] if k > 0 else collected
	answer = ''.join(collected)
	return answer